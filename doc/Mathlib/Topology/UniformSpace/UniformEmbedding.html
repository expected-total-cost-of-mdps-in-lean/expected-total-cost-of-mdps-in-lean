<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Topology.UniformSpace.UniformEmbedding</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Topology.UniformSpace.UniformEmbedding";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Topology</span>.<span class="name">UniformSpace</span>.<span class="name">UniformEmbedding</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Topology/DenseEmbedding.html">Mathlib.Topology.DenseEmbedding</a></li><li><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html">Mathlib.Topology.UniformSpace.Cauchy</a></li><li><a href="../../.././Mathlib/Topology/UniformSpace/Separation.html">Mathlib.Topology.UniformSpace.Separation</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Topology.UniformSpace.UniformEmbedding" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#isUniformInducing_iff"><span class="name">isUniformInducing_iff</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing"><span class="name">IsUniformInducing</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.comap_uniformity"><span class="name">IsUniformInducing</span>.<span class="name">comap_uniformity</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing"><span class="name">UniformInducing</span></a></div><div class="nav_link"><a class="break_within" href="#isUniformInducing_iff_uniformSpace"><span class="name">isUniformInducing_iff_uniformSpace</span></a></div><div class="nav_link"><a class="break_within" href="#uniformInducing_iff_uniformSpace"><span class="name">uniformInducing_iff_uniformSpace</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.comap_uniformSpace"><span class="name">IsUniformInducing</span>.<span class="name">comap_uniformSpace</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.comap_uniformSpace"><span class="name">UniformInducing</span>.<span class="name">comap_uniformSpace</span></a></div><div class="nav_link"><a class="break_within" href="#isUniformInducing_iff'"><span class="name">isUniformInducing_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#uniformInducing_iff'"><span class="name">uniformInducing_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.HasBasis.isUniformInducing_iff"><span class="name">Filter</span>.<span class="name">HasBasis</span>.<span class="name">isUniformInducing_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.HasBasis.uniformInducing_iff"><span class="name">Filter</span>.<span class="name">HasBasis</span>.<span class="name">uniformInducing_iff</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.mk'"><span class="name">IsUniformInducing</span>.<span class="name">mk'</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.mk'"><span class="name">UniformInducing</span>.<span class="name">mk'</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.id"><span class="name">IsUniformInducing</span>.<span class="name">id</span></a></div><div class="nav_link"><a class="break_within" href="#uniformInducing_id"><span class="name">uniformInducing_id</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.comp"><span class="name">IsUniformInducing</span>.<span class="name">comp</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.comp"><span class="name">UniformInducing</span>.<span class="name">comp</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.of_comp_iff"><span class="name">IsUniformInducing</span>.<span class="name">of_comp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.of_comp_iff"><span class="name">UniformInducing</span>.<span class="name">of_comp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.basis_uniformity"><span class="name">IsUniformInducing</span>.<span class="name">basis_uniformity</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.basis_uniformity"><span class="name">UniformInducing</span>.<span class="name">basis_uniformity</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.cauchy_map_iff"><span class="name">IsUniformInducing</span>.<span class="name">cauchy_map_iff</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.cauchy_map_iff"><span class="name">UniformInducing</span>.<span class="name">cauchy_map_iff</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.of_comp"><span class="name">IsUniformInducing</span>.<span class="name">of_comp</span></a></div><div class="nav_link"><a class="break_within" href="#uniformInducing_of_compose"><span class="name">uniformInducing_of_compose</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.uniformContinuous"><span class="name">IsUniformInducing</span>.<span class="name">uniformContinuous</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.uniformContinuous"><span class="name">UniformInducing</span>.<span class="name">uniformContinuous</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.uniformContinuous_iff"><span class="name">IsUniformInducing</span>.<span class="name">uniformContinuous_iff</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.uniformContinuous_iff"><span class="name">UniformInducing</span>.<span class="name">uniformContinuous_iff</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.isUniformInducing_comp_iff"><span class="name">IsUniformInducing</span>.<span class="name">isUniformInducing_comp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.uniformInducing_comp_iff"><span class="name">UniformInducing</span>.<span class="name">uniformInducing_comp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.uniformContinuousOn_iff"><span class="name">IsUniformInducing</span>.<span class="name">uniformContinuousOn_iff</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.uniformContinuousOn_iff"><span class="name">UniformInducing</span>.<span class="name">uniformContinuousOn_iff</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.inducing"><span class="name">IsUniformInducing</span>.<span class="name">inducing</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.inducing"><span class="name">UniformInducing</span>.<span class="name">inducing</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.prod"><span class="name">IsUniformInducing</span>.<span class="name">prod</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.prod"><span class="name">UniformInducing</span>.<span class="name">prod</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.isDenseInducing"><span class="name">IsUniformInducing</span>.<span class="name">isDenseInducing</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.isDenseInducing"><span class="name">UniformInducing</span>.<span class="name">isDenseInducing</span></a></div><div class="nav_link"><a class="break_within" href="#SeparationQuotient.isUniformInducing_mk"><span class="name">SeparationQuotient</span>.<span class="name">isUniformInducing_mk</span></a></div><div class="nav_link"><a class="break_within" href="#SeparationQuotient.uniformInducing_mk"><span class="name">SeparationQuotient</span>.<span class="name">uniformInducing_mk</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.injective"><span class="name">IsUniformInducing</span>.<span class="name">injective</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.injective"><span class="name">UniformInducing</span>.<span class="name">injective</span></a></div><div class="nav_link"><a class="break_within" href="#isUniformEmbedding_iff"><span class="name">isUniformEmbedding_iff</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformEmbedding"><span class="name">IsUniformEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformEmbedding.inj"><span class="name">IsUniformEmbedding</span>.<span class="name">inj</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformEmbedding.isUniformInducing"><span class="name">IsUniformEmbedding</span>.<span class="name">isUniformInducing</span></a></div><div class="nav_link"><a class="break_within" href="#UniformEmbedding"><span class="name">UniformEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#isUniformEmbedding_iff'"><span class="name">isUniformEmbedding_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#uniformEmbedding_iff'"><span class="name">uniformEmbedding_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.HasBasis.isUniformEmbedding_iff'"><span class="name">Filter</span>.<span class="name">HasBasis</span>.<span class="name">isUniformEmbedding_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.HasBasis.uniformEmbedding_iff'"><span class="name">Filter</span>.<span class="name">HasBasis</span>.<span class="name">uniformEmbedding_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.HasBasis.isUniformEmbedding_iff"><span class="name">Filter</span>.<span class="name">HasBasis</span>.<span class="name">isUniformEmbedding_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.HasBasis.uniformEmbedding_iff"><span class="name">Filter</span>.<span class="name">HasBasis</span>.<span class="name">uniformEmbedding_iff</span></a></div><div class="nav_link"><a class="break_within" href="#isUniformEmbedding_subtype_val"><span class="name">isUniformEmbedding_subtype_val</span></a></div><div class="nav_link"><a class="break_within" href="#uniformEmbedding_subtype_val"><span class="name">uniformEmbedding_subtype_val</span></a></div><div class="nav_link"><a class="break_within" href="#isUniformEmbedding_set_inclusion"><span class="name">isUniformEmbedding_set_inclusion</span></a></div><div class="nav_link"><a class="break_within" href="#uniformEmbedding_set_inclusion"><span class="name">uniformEmbedding_set_inclusion</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformEmbedding.comp"><span class="name">IsUniformEmbedding</span>.<span class="name">comp</span></a></div><div class="nav_link"><a class="break_within" href="#UniformEmbedding.comp"><span class="name">UniformEmbedding</span>.<span class="name">comp</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformEmbedding.of_comp_iff"><span class="name">IsUniformEmbedding</span>.<span class="name">of_comp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#UniformEmbedding.of_comp_iff"><span class="name">UniformEmbedding</span>.<span class="name">of_comp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Equiv.isUniformEmbedding"><span class="name">Equiv</span>.<span class="name">isUniformEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#Equiv.uniformEmbedding"><span class="name">Equiv</span>.<span class="name">uniformEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#isUniformEmbedding_inl"><span class="name">isUniformEmbedding_inl</span></a></div><div class="nav_link"><a class="break_within" href="#uniformEmbedding_inl"><span class="name">uniformEmbedding_inl</span></a></div><div class="nav_link"><a class="break_within" href="#isUniformEmbedding_inr"><span class="name">isUniformEmbedding_inr</span></a></div><div class="nav_link"><a class="break_within" href="#uniformEmbedding_inr"><span class="name">uniformEmbedding_inr</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.isUniformEmbedding"><span class="name">IsUniformInducing</span>.<span class="name">isUniformEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.isUniformEmbedding"><span class="name">UniformInducing</span>.<span class="name">isUniformEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.uniformEmbedding"><span class="name">IsUniformInducing</span>.<span class="name">uniformEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#isUniformEmbedding_iff_isUniformInducing"><span class="name">isUniformEmbedding_iff_isUniformInducing</span></a></div><div class="nav_link"><a class="break_within" href="#isUniformEmbedding_iff_uniformInducing"><span class="name">isUniformEmbedding_iff_uniformInducing</span></a></div><div class="nav_link"><a class="break_within" href="#uniformEmbedding_iff_isUniformInducing"><span class="name">uniformEmbedding_iff_isUniformInducing</span></a></div><div class="nav_link"><a class="break_within" href="#comap_uniformity_of_spaced_out"><span class="name">comap_uniformity_of_spaced_out</span></a></div><div class="nav_link"><a class="break_within" href="#isUniformEmbedding_of_spaced_out"><span class="name">isUniformEmbedding_of_spaced_out</span></a></div><div class="nav_link"><a class="break_within" href="#uniformEmbedding_of_spaced_out"><span class="name">uniformEmbedding_of_spaced_out</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformEmbedding.embedding"><span class="name">IsUniformEmbedding</span>.<span class="name">embedding</span></a></div><div class="nav_link"><a class="break_within" href="#UniformEmbedding.embedding"><span class="name">UniformEmbedding</span>.<span class="name">embedding</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformEmbedding.isDenseEmbedding"><span class="name">IsUniformEmbedding</span>.<span class="name">isDenseEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#UniformEmbedding.isDenseEmbedding"><span class="name">UniformEmbedding</span>.<span class="name">isDenseEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformEmbedding.denseEmbedding"><span class="name">IsUniformEmbedding</span>.<span class="name">denseEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#closedEmbedding_of_spaced_out"><span class="name">closedEmbedding_of_spaced_out</span></a></div><div class="nav_link"><a class="break_within" href="#closure_image_mem_nhds_of_isUniformInducing"><span class="name">closure_image_mem_nhds_of_isUniformInducing</span></a></div><div class="nav_link"><a class="break_within" href="#closure_image_mem_nhds_of_uniformInducing"><span class="name">closure_image_mem_nhds_of_uniformInducing</span></a></div><div class="nav_link"><a class="break_within" href="#isUniformEmbedding_subtypeEmb"><span class="name">isUniformEmbedding_subtypeEmb</span></a></div><div class="nav_link"><a class="break_within" href="#uniformEmbedding_subtypeEmb"><span class="name">uniformEmbedding_subtypeEmb</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformEmbedding.prod"><span class="name">IsUniformEmbedding</span>.<span class="name">prod</span></a></div><div class="nav_link"><a class="break_within" href="#UniformEmbedding.prod"><span class="name">UniformEmbedding</span>.<span class="name">prod</span></a></div><div class="nav_link"><a class="break_within" href="#isComplete_image_iff"><span class="name">isComplete_image_iff</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.isComplete_iff"><span class="name">IsUniformInducing</span>.<span class="name">isComplete_iff</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.isComplete_iff"><span class="name">UniformInducing</span>.<span class="name">isComplete_iff</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformEmbedding.isComplete_iff"><span class="name">IsUniformEmbedding</span>.<span class="name">isComplete_iff</span></a></div><div class="nav_link"><a class="break_within" href="#UniformEmbedding.isComplete_iff"><span class="name">UniformEmbedding</span>.<span class="name">isComplete_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.isComplete_iff"><span class="name">Subtype</span>.<span class="name">isComplete_iff</span></a></div><div class="nav_link"><a class="break_within" href="#isComplete_of_complete_image"><span class="name">isComplete_of_complete_image</span></a></div><div class="nav_link"><a class="break_within" href="#completeSpace_iff_isComplete_range"><span class="name">completeSpace_iff_isComplete_range</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.completeSpace"><span class="name">IsUniformInducing</span>.<span class="name">completeSpace</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.completeSpace"><span class="name">UniformInducing</span>.<span class="name">completeSpace</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.isComplete_range"><span class="name">IsUniformInducing</span>.<span class="name">isComplete_range</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.isComplete_range"><span class="name">UniformInducing</span>.<span class="name">isComplete_range</span></a></div><div class="nav_link"><a class="break_within" href="#IsUniformInducing.completeSpace_congr"><span class="name">IsUniformInducing</span>.<span class="name">completeSpace_congr</span></a></div><div class="nav_link"><a class="break_within" href="#UniformInducing.completeSpace_congr"><span class="name">UniformInducing</span>.<span class="name">completeSpace_congr</span></a></div><div class="nav_link"><a class="break_within" href="#SeparationQuotient.completeSpace_iff"><span class="name">SeparationQuotient</span>.<span class="name">completeSpace_iff</span></a></div><div class="nav_link"><a class="break_within" href="#SeparationQuotient.instCompleteSpace"><span class="name">SeparationQuotient</span>.<span class="name">instCompleteSpace</span></a></div><div class="nav_link"><a class="break_within" href="#completeSpace_congr"><span class="name">completeSpace_congr</span></a></div><div class="nav_link"><a class="break_within" href="#completeSpace_coe_iff_isComplete"><span class="name">completeSpace_coe_iff_isComplete</span></a></div><div class="nav_link"><a class="break_within" href="#IsComplete.completeSpace_coe"><span class="name">IsComplete</span>.<span class="name">completeSpace_coe</span></a></div><div class="nav_link"><a class="break_within" href="#IsClosed.completeSpace_coe"><span class="name">IsClosed</span>.<span class="name">completeSpace_coe</span></a></div><div class="nav_link"><a class="break_within" href="#completeSpace_ulift_iff"><span class="name">completeSpace_ulift_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ULift.instCompleteSpace"><span class="name">ULift</span>.<span class="name">instCompleteSpace</span></a></div><div class="nav_link"><a class="break_within" href="#completeSpace_extension"><span class="name">completeSpace_extension</span></a></div><div class="nav_link"><a class="break_within" href="#totallyBounded_image_iff"><span class="name">totallyBounded_image_iff</span></a></div><div class="nav_link"><a class="break_within" href="#totallyBounded_preimage"><span class="name">totallyBounded_preimage</span></a></div><div class="nav_link"><a class="break_within" href="#CompleteSpace.sum"><span class="name">CompleteSpace</span>.<span class="name">sum</span></a></div><div class="nav_link"><a class="break_within" href="#isUniformEmbedding_comap"><span class="name">isUniformEmbedding_comap</span></a></div><div class="nav_link"><a class="break_within" href="#uniformEmbedding_comap"><span class="name">uniformEmbedding_comap</span></a></div><div class="nav_link"><a class="break_within" href="#Embedding.comapUniformSpace"><span class="name">Embedding</span>.<span class="name">comapUniformSpace</span></a></div><div class="nav_link"><a class="break_within" href="#Embedding.to_isUniformEmbedding"><span class="name">Embedding</span>.<span class="name">to_isUniformEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#Embedding.to_uniformEmbedding"><span class="name">Embedding</span>.<span class="name">to_uniformEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#uniformly_extend_exists"><span class="name">uniformly_extend_exists</span></a></div><div class="nav_link"><a class="break_within" href="#uniform_extend_subtype"><span class="name">uniform_extend_subtype</span></a></div><div class="nav_link"><a class="break_within" href="#uniformly_extend_spec"><span class="name">uniformly_extend_spec</span></a></div><div class="nav_link"><a class="break_within" href="#uniformContinuous_uniformly_extend"><span class="name">uniformContinuous_uniformly_extend</span></a></div><div class="nav_link"><a class="break_within" href="#uniformly_extend_of_ind"><span class="name">uniformly_extend_of_ind</span></a></div><div class="nav_link"><a class="break_within" href="#uniformly_extend_unique"><span class="name">uniformly_extend_unique</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Uniform-embeddings-of-uniform-spaces">Uniform embeddings of uniform spaces. <a class="hover-link" href="#Uniform-embeddings-of-uniform-spaces">#</a></h1><p>Extension of uniform continuous functions.</p></div><div class="mod_doc"><h3 class="markdown-heading" id="Uniform-inducing-maps">Uniform inducing maps <a class="hover-link" href="#Uniform-inducing-maps">#</a></h3></div><div class="decl" id="isUniformInducing_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformInducing_iff"><span class="name">isUniformInducing_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span></span>) =&gt; <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.1</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.2</span></span>)</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span></span></span></span></div></div></div></div><div class="decl" id="IsUniformInducing"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing"><span class="name">IsUniformInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A map <code>f : α → β</code> between uniform spaces is called <em>uniform inducing</em> if the uniformity filter
on <code>α</code> is the pullback of the uniformity filter on <code>β</code> under <code><a href="../../.././Init/Core.html#Prod.map">Prod.map</a> f f</code>. If <code>α</code> is a separated
space, then this implies that <code>f</code> is injective, hence it is a <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a></code>.</p><ul class="structure_fields" id="IsUniformInducing.mk"><li id="IsUniformInducing.comap_uniformity" class="structure_field"><div class="structure_field_info">comap_uniformity : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span></span>) =&gt; <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.1</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.2</span></span>)</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>The uniformity filter on the domain is the pullback of the uniformity filter on the codomain
under <code><a href="../../.././Init/Core.html#Prod.map">Prod.map</a> f f</code>.</p></div></li></ul><details id="instances-for-list-IsUniformInducing" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="IsUniformInducing.comap_uniformity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.comap_uniformity"><span class="name">IsUniformInducing</span>.<span class="name">comap_uniformity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span></span>) =&gt; <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.1</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.2</span></span>)</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span></span></span></div></div><p>The uniformity filter on the domain is the pullback of the uniformity filter on the codomain
under <code><a href="../../.././Init/Core.html#Prod.map">Prod.map</a> f f</code>.</p></div></div><div class="decl" id="UniformInducing"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing"><span class="name">UniformInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a></code>.</p><hr></hr><p>A map <code>f : α → β</code> between uniform spaces is called <em>uniform inducing</em> if the uniformity filter
on <code>α</code> is the pullback of the uniformity filter on <code>β</code> under <code><a href="../../.././Init/Core.html#Prod.map">Prod.map</a> f f</code>. If <code>α</code> is a separated
space, then this implies that <code>f</code> is injective, hence it is a <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing">@<a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing">UniformInducing</a></a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">@<a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a></a></span></li></ul></details><details id="instances-for-list-UniformInducing" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="isUniformInducing_iff_uniformSpace"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformInducing_iff_uniformSpace"><span class="name">isUniformInducing_iff_uniformSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> <span class="fn">f</span> <span class="fn">inst✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst✝¹</span></span></span></div></div></div></div><div class="decl" id="uniformInducing_iff_uniformSpace"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated isUniformInducing_iff_uniformSpace]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformInducing_iff_uniformSpace"><span class="name">uniformInducing_iff_uniformSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> <span class="fn">f</span> <span class="fn">inst✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst✝¹</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformInducing_iff_uniformSpace">isUniformInducing_iff_uniformSpace</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.comap_uniformSpace"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.comap_uniformSpace"><span class="name">IsUniformInducing</span>.<span class="name">comap_uniformSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> <span class="fn">f</span> <span class="fn">inst✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst✝¹</span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformInducing_iff_uniformSpace">isUniformInducing_iff_uniformSpace</a></code>.</p></div></div><div class="decl" id="UniformInducing.comap_uniformSpace"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.comap_uniformSpace]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.comap_uniformSpace"><span class="name">UniformInducing</span>.<span class="name">comap_uniformSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> <span class="fn">f</span> <span class="fn">inst✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst✝¹</span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformInducing_iff_uniformSpace">isUniformInducing_iff_uniformSpace</a></code>.</p><hr></hr><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformInducing_iff_uniformSpace">isUniformInducing_iff_uniformSpace</a></code>.</p></div></div><div class="decl" id="isUniformInducing_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformInducing_iff'"><span class="name">isUniformInducing_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">(<a href="../../.././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">f</span> <span class="fn">f</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span></span></span></span></span></div></div></div></div><div class="decl" id="uniformInducing_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated isUniformInducing_iff']</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformInducing_iff'"><span class="name">uniformInducing_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">(<a href="../../.././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">f</span> <span class="fn">f</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformInducing_iff'">isUniformInducing_iff'</a></code>.</p></div></div><div class="decl" id="Filter.HasBasis.isUniformInducing_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Filter.HasBasis.isUniformInducing_iff"><span class="name">Filter</span>.<span class="name">HasBasis</span>.<span class="name">isUniformInducing_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι' : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p' : <span class="fn"><span class="fn">ι'</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s' : <span class="fn"><span class="fn">ι'</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span>)</span>.HasBasis</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.HasBasis</span> <span class="fn">p'</span> <span class="fn">s'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(∀ (<span class="fn">i</span> : <span class="fn">ι'</span>), <span class="fn"><span class="fn"><span class="fn">p'</span> <span class="fn">i</span></span> → <span class="fn">∃ (<span class="fn">j</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s</span> <span class="fn">j</span></span></span> → <span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s'</span> <span class="fn">i</span></span></span></span></span></span></span></span>)</span> <a href="../../.././Init/Prelude.html#And">∧</a>     <span class="fn">∀ (<span class="fn">j</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">j</span></span> → <span class="fn">∃ (<span class="fn">i</span> : <span class="fn">ι'</span>), <span class="fn"><span class="fn"><span class="fn">p'</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s'</span> <span class="fn">i</span></span></span> → <span class="fn"><span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s</span> <span class="fn">j</span></span></span></span></span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="Filter.HasBasis.uniformInducing_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated Filter.HasBasis.isUniformInducing_iff]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Filter.HasBasis.uniformInducing_iff"><span class="name">Filter</span>.<span class="name">HasBasis</span>.<span class="name">uniformInducing_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι' : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p' : <span class="fn"><span class="fn">ι'</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s' : <span class="fn"><span class="fn">ι'</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span>)</span>.HasBasis</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.HasBasis</span> <span class="fn">p'</span> <span class="fn">s'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(∀ (<span class="fn">i</span> : <span class="fn">ι'</span>), <span class="fn"><span class="fn"><span class="fn">p'</span> <span class="fn">i</span></span> → <span class="fn">∃ (<span class="fn">j</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s</span> <span class="fn">j</span></span></span> → <span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s'</span> <span class="fn">i</span></span></span></span></span></span></span></span>)</span> <a href="../../.././Init/Prelude.html#And">∧</a>     <span class="fn">∀ (<span class="fn">j</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">j</span></span> → <span class="fn">∃ (<span class="fn">i</span> : <span class="fn">ι'</span>), <span class="fn"><span class="fn"><span class="fn">p'</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s'</span> <span class="fn">i</span></span></span> → <span class="fn"><span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s</span> <span class="fn">j</span></span></span></span></span></span></span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Filter.HasBasis.isUniformInducing_iff">Filter.HasBasis.isUniformInducing_iff</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.mk'"><span class="name">IsUniformInducing</span>.<span class="name">mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>)</span></span>), <span class="fn"><span class="fn"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span></span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ <span class="fn">t</span> ∈ <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span>, <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> → <span class="fn"><span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="UniformInducing.mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.mk']</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.mk'"><span class="name">UniformInducing</span>.<span class="name">mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>)</span></span>), <span class="fn"><span class="fn"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span></span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ <span class="fn">t</span> ∈ <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span>, <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> → <span class="fn"><span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.mk'">IsUniformInducing.mk'</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.id"><span class="name">IsUniformInducing</span>.<span class="name">id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">id</span></span></div></div></div></div><div class="decl" id="uniformInducing_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.id]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformInducing_id"><span class="name">uniformInducing_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">id</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.id">IsUniformInducing.id</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.comp"><span class="name">IsUniformInducing</span>.<span class="name">comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="UniformInducing.comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.comp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.comp"><span class="name">UniformInducing</span>.<span class="name">comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.comp">IsUniformInducing.comp</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.of_comp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.of_comp_iff"><span class="name">IsUniformInducing</span>.<span class="name">of_comp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="UniformInducing.of_comp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.of_comp_iff]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.of_comp_iff"><span class="name">UniformInducing</span>.<span class="name">of_comp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.of_comp_iff">IsUniformInducing.of_comp_iff</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.basis_uniformity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.basis_uniformity"><span class="name">IsUniformInducing</span>.<span class="name">basis_uniformity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.HasBasis</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span>)</span>.HasBasis</span> <span class="fn">p</span> <span class="fn">fun (<span class="fn">i</span> : <span class="fn">ι</span>) =&gt; <span class="fn"><span class="fn"><a href="../../.././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">f</span> <span class="fn">f</span></span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">⁻¹'</a> <span class="fn"><span class="fn">s</span> <span class="fn">i</span></span></span></span></span></div></div></div></div><div class="decl" id="UniformInducing.basis_uniformity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.basis_uniformity]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.basis_uniformity"><span class="name">UniformInducing</span>.<span class="name">basis_uniformity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.HasBasis</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span>)</span>.HasBasis</span> <span class="fn">p</span> <span class="fn">fun (<span class="fn">i</span> : <span class="fn">ι</span>) =&gt; <span class="fn"><span class="fn"><a href="../../.././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">f</span> <span class="fn">f</span></span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">⁻¹'</a> <span class="fn"><span class="fn">s</span> <span class="fn">i</span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.basis_uniformity">IsUniformInducing.basis_uniformity</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.cauchy_map_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.cauchy_map_iff"><span class="name">IsUniformInducing</span>.<span class="name">cauchy_map_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#Cauchy">Cauchy</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">f</span> <span class="fn">F</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#Cauchy">Cauchy</a> <span class="fn">F</span></span></span></div></div></div></div><div class="decl" id="UniformInducing.cauchy_map_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.cauchy_map_iff]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.cauchy_map_iff"><span class="name">UniformInducing</span>.<span class="name">cauchy_map_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#Cauchy">Cauchy</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">f</span> <span class="fn">F</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#Cauchy">Cauchy</a> <span class="fn">F</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.cauchy_map_iff">IsUniformInducing.cauchy_map_iff</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.of_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.of_comp"><span class="name">IsUniformInducing</span>.<span class="name">of_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hgf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="uniformInducing_of_compose"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.of_comp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformInducing_of_compose"><span class="name">uniformInducing_of_compose</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hgf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.of_comp">IsUniformInducing.of_comp</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.uniformContinuous"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.uniformContinuous"><span class="name">IsUniformInducing</span>.<span class="name">uniformContinuous</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="UniformInducing.uniformContinuous"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.uniformContinuous]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.uniformContinuous"><span class="name">UniformInducing</span>.<span class="name">uniformContinuous</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.uniformContinuous">IsUniformInducing.uniformContinuous</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.uniformContinuous_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.uniformContinuous_iff"><span class="name">IsUniformInducing</span>.<span class="name">uniformContinuous_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span></span></div></div></div></div><div class="decl" id="UniformInducing.uniformContinuous_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.uniformContinuous_iff]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.uniformContinuous_iff"><span class="name">UniformInducing</span>.<span class="name">uniformContinuous_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.uniformContinuous_iff">IsUniformInducing.uniformContinuous_iff</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.isUniformInducing_comp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.isUniformInducing_comp_iff"><span class="name">IsUniformInducing</span>.<span class="name">isUniformInducing_comp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="UniformInducing.uniformInducing_comp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.isUniformInducing_comp_iff]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.uniformInducing_comp_iff"><span class="name">UniformInducing</span>.<span class="name">uniformInducing_comp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.isUniformInducing_comp_iff">IsUniformInducing.isUniformInducing_comp_iff</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.uniformContinuousOn_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.uniformContinuousOn_iff"><span class="name">IsUniformInducing</span>.<span class="name">uniformContinuousOn_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuousOn">UniformContinuousOn</a> <span class="fn">f</span> <span class="fn">S</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuousOn">UniformContinuousOn</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span> <span class="fn">S</span></span></span></div></div></div></div><div class="decl" id="UniformInducing.uniformContinuousOn_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.uniformContinuousOn_iff]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.uniformContinuousOn_iff"><span class="name">UniformInducing</span>.<span class="name">uniformContinuousOn_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuousOn">UniformContinuousOn</a> <span class="fn">f</span> <span class="fn">S</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuousOn">UniformContinuousOn</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span> <span class="fn">S</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.uniformContinuousOn_iff">IsUniformInducing.uniformContinuousOn_iff</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.inducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.inducing"><span class="name">IsUniformInducing</span>.<span class="name">inducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Inducing">Inducing</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="UniformInducing.inducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.inducing]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.inducing"><span class="name">UniformInducing</span>.<span class="name">inducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Inducing">Inducing</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.inducing">IsUniformInducing.inducing</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.prod"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.prod"><span class="name">IsUniformInducing</span>.<span class="name">prod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α' : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β' : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e₁ : <span class="fn"><span class="fn">α</span> → <span class="fn">α'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e₂ : <span class="fn"><span class="fn">β</span> → <span class="fn">β'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">e₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">e₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">fun (<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>) =&gt; <span class="fn">(<span class="fn"><span class="fn">e₁</span> <span class="fn"><span class="fn">p</span>.1</span></span>, <span class="fn"><span class="fn">e₂</span> <span class="fn"><span class="fn">p</span>.2</span></span>)</span></span></span></div></div></div></div><div class="decl" id="UniformInducing.prod"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.prod]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.prod"><span class="name">UniformInducing</span>.<span class="name">prod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α' : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β' : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e₁ : <span class="fn"><span class="fn">α</span> → <span class="fn">α'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e₂ : <span class="fn"><span class="fn">β</span> → <span class="fn">β'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">e₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">e₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">fun (<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>) =&gt; <span class="fn">(<span class="fn"><span class="fn">e₁</span> <span class="fn"><span class="fn">p</span>.1</span></span>, <span class="fn"><span class="fn">e₂</span> <span class="fn"><span class="fn">p</span>.2</span></span>)</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.prod">IsUniformInducing.prod</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.isDenseInducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.isDenseInducing"><span class="name">IsUniformInducing</span>.<span class="name">isDenseInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hd : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#DenseRange">DenseRange</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/DenseEmbedding.html#IsDenseInducing">IsDenseInducing</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="UniformInducing.isDenseInducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.isDenseInducing]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.isDenseInducing"><span class="name">UniformInducing</span>.<span class="name">isDenseInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hd : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#DenseRange">DenseRange</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/DenseEmbedding.html#IsDenseInducing">IsDenseInducing</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.isDenseInducing">IsUniformInducing.isDenseInducing</a></code>.</p></div></div><div class="decl" id="SeparationQuotient.isUniformInducing_mk"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#SeparationQuotient.isUniformInducing_mk"><span class="name">SeparationQuotient</span>.<span class="name">isUniformInducing_mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">SeparationQuotient.mk</span></span></div></div></div></div><div class="decl" id="SeparationQuotient.uniformInducing_mk"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated SeparationQuotient.isUniformInducing_mk]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#SeparationQuotient.uniformInducing_mk"><span class="name">SeparationQuotient</span>.<span class="name">uniformInducing_mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">SeparationQuotient.mk</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#SeparationQuotient.isUniformInducing_mk">SeparationQuotient.isUniformInducing_mk</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.injective"><span class="name">IsUniformInducing</span>.<span class="name">injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T0Space">T0Space</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="UniformInducing.injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.injective]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.injective"><span class="name">UniformInducing</span>.<span class="name">injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T0Space">T0Space</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.injective">IsUniformInducing.injective</a></code>.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Uniform-embeddings">Uniform embeddings <a class="hover-link" href="#Uniform-embeddings">#</a></h3></div><div class="decl" id="isUniformEmbedding_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_iff"><span class="name">isUniformEmbedding_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="IsUniformEmbedding"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding"><span class="name">IsUniformEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing"><span class="name">IsUniformInducing</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A map <code>f : α → β</code> between uniform spaces is a <em>uniform embedding</em> if it is uniform inducing and
injective. If <code>α</code> is a separated space, then the latter assumption follows from the former.</p><ul class="structure_fields" id="IsUniformEmbedding.mk"><li id="IsUniformEmbedding.comap_uniformity" class="structure_field"><div class="structure_field_info">comap_uniformity : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span></span>) =&gt; <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.1</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.2</span></span>)</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span></span></span></div></li><li id="IsUniformEmbedding.inj" class="structure_field"><div class="structure_field_info">inj : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span></div><div class="structure_field_doc"><p>A uniform embedding is injective.</p></div></li></ul><details id="instances-for-list-IsUniformEmbedding" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="IsUniformEmbedding.inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.inj"><span class="name">IsUniformEmbedding</span>.<span class="name">inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span></div></div><p>A uniform embedding is injective.</p></div></div><div class="decl" id="IsUniformEmbedding.isUniformInducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.isUniformInducing"><span class="name">IsUniformEmbedding</span>.<span class="name">isUniformInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="UniformEmbedding"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformEmbedding]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformEmbedding"><span class="name">UniformEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a></code>.</p><hr></hr><p>A map <code>f : α → β</code> between uniform spaces is a <em>uniform embedding</em> if it is uniform inducing and
injective. If <code>α</code> is a separated space, then the latter assumption follows from the former.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformEmbedding">@<a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformEmbedding">UniformEmbedding</a></a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">@<a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a></a></span></li></ul></details><details id="instances-for-list-UniformEmbedding" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="isUniformEmbedding_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_iff'"><span class="name">isUniformEmbedding_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">(<a href="../../.././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">f</span> <span class="fn">f</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span></span></span></span></span></span></div></div></div></div><div class="decl" id="uniformEmbedding_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated isUniformEmbedding_iff']</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformEmbedding_iff'"><span class="name">uniformEmbedding_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">(<a href="../../.././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">f</span> <span class="fn">f</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span></span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_iff'">isUniformEmbedding_iff'</a></code>.</p></div></div><div class="decl" id="Filter.HasBasis.isUniformEmbedding_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Filter.HasBasis.isUniformEmbedding_iff'"><span class="name">Filter</span>.<span class="name">HasBasis</span>.<span class="name">isUniformEmbedding_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι' : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p' : <span class="fn"><span class="fn">ι'</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s' : <span class="fn"><span class="fn">ι'</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span>)</span>.HasBasis</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.HasBasis</span> <span class="fn">p'</span> <span class="fn">s'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn">(∀ (<span class="fn">i</span> : <span class="fn">ι'</span>), <span class="fn"><span class="fn"><span class="fn">p'</span> <span class="fn">i</span></span> → <span class="fn">∃ (<span class="fn">j</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s</span> <span class="fn">j</span></span></span> → <span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s'</span> <span class="fn">i</span></span></span></span></span></span></span></span>)</span> <a href="../../.././Init/Prelude.html#And">∧</a>       <span class="fn">∀ (<span class="fn">j</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">j</span></span> → <span class="fn">∃ (<span class="fn">i</span> : <span class="fn">ι'</span>), <span class="fn"><span class="fn"><span class="fn">p'</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s'</span> <span class="fn">i</span></span></span> → <span class="fn"><span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s</span> <span class="fn">j</span></span></span></span></span></span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="Filter.HasBasis.uniformEmbedding_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated Filter.HasBasis.isUniformEmbedding_iff']</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Filter.HasBasis.uniformEmbedding_iff'"><span class="name">Filter</span>.<span class="name">HasBasis</span>.<span class="name">uniformEmbedding_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι' : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p' : <span class="fn"><span class="fn">ι'</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s' : <span class="fn"><span class="fn">ι'</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span>)</span>.HasBasis</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.HasBasis</span> <span class="fn">p'</span> <span class="fn">s'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn">(∀ (<span class="fn">i</span> : <span class="fn">ι'</span>), <span class="fn"><span class="fn"><span class="fn">p'</span> <span class="fn">i</span></span> → <span class="fn">∃ (<span class="fn">j</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s</span> <span class="fn">j</span></span></span> → <span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s'</span> <span class="fn">i</span></span></span></span></span></span></span></span>)</span> <a href="../../.././Init/Prelude.html#And">∧</a>       <span class="fn">∀ (<span class="fn">j</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">j</span></span> → <span class="fn">∃ (<span class="fn">i</span> : <span class="fn">ι'</span>), <span class="fn"><span class="fn"><span class="fn">p'</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s'</span> <span class="fn">i</span></span></span> → <span class="fn"><span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s</span> <span class="fn">j</span></span></span></span></span></span></span></span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Filter.HasBasis.isUniformEmbedding_iff'">Filter.HasBasis.isUniformEmbedding_iff'</a></code>.</p></div></div><div class="decl" id="Filter.HasBasis.isUniformEmbedding_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Filter.HasBasis.isUniformEmbedding_iff"><span class="name">Filter</span>.<span class="name">HasBasis</span>.<span class="name">isUniformEmbedding_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι' : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p' : <span class="fn"><span class="fn">ι'</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s' : <span class="fn"><span class="fn">ι'</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span>)</span>.HasBasis</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.HasBasis</span> <span class="fn">p'</span> <span class="fn">s'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">j</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">j</span></span> → <span class="fn">∃ (<span class="fn">i</span> : <span class="fn">ι'</span>), <span class="fn"><span class="fn"><span class="fn">p'</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s'</span> <span class="fn">i</span></span></span> → <span class="fn"><span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s</span> <span class="fn">j</span></span></span></span></span></span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="Filter.HasBasis.uniformEmbedding_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated Filter.HasBasis.isUniformEmbedding_iff]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Filter.HasBasis.uniformEmbedding_iff"><span class="name">Filter</span>.<span class="name">HasBasis</span>.<span class="name">uniformEmbedding_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι' : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p' : <span class="fn"><span class="fn">ι'</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s' : <span class="fn"><span class="fn">ι'</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span>)</span>.HasBasis</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.HasBasis</span> <span class="fn">p'</span> <span class="fn">s'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">j</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">j</span></span> → <span class="fn">∃ (<span class="fn">i</span> : <span class="fn">ι'</span>), <span class="fn"><span class="fn"><span class="fn">p'</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s'</span> <span class="fn">i</span></span></span> → <span class="fn"><span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s</span> <span class="fn">j</span></span></span></span></span></span></span></span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Filter.HasBasis.isUniformEmbedding_iff">Filter.HasBasis.isUniformEmbedding_iff</a></code>.</p></div></div><div class="decl" id="isUniformEmbedding_subtype_val"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_subtype_val"><span class="name">isUniformEmbedding_subtype_val</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">Subtype.val</span></span></div></div></div></div><div class="decl" id="uniformEmbedding_subtype_val"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated isUniformEmbedding_subtype_val]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformEmbedding_subtype_val"><span class="name">uniformEmbedding_subtype_val</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">Subtype.val</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_subtype_val">isUniformEmbedding_subtype_val</a></code>.</p></div></div><div class="decl" id="isUniformEmbedding_set_inclusion"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_set_inclusion"><span class="name">isUniformEmbedding_set_inclusion</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hst : <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Basic.html#Set.inclusion">Set.inclusion</a> <span class="fn">hst</span>)</span></span></div></div></div></div><div class="decl" id="uniformEmbedding_set_inclusion"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated isUniformEmbedding_set_inclusion]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformEmbedding_set_inclusion"><span class="name">uniformEmbedding_set_inclusion</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hst : <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Basic.html#Set.inclusion">Set.inclusion</a> <span class="fn">hst</span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_set_inclusion">isUniformEmbedding_set_inclusion</a></code>.</p></div></div><div class="decl" id="IsUniformEmbedding.comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.comp"><span class="name">IsUniformEmbedding</span>.<span class="name">comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="UniformEmbedding.comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformEmbedding.comp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformEmbedding.comp"><span class="name">UniformEmbedding</span>.<span class="name">comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.comp">IsUniformEmbedding.comp</a></code>.</p></div></div><div class="decl" id="IsUniformEmbedding.of_comp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.of_comp_iff"><span class="name">IsUniformEmbedding</span>.<span class="name">of_comp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="UniformEmbedding.of_comp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformEmbedding.of_comp_iff]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformEmbedding.of_comp_iff"><span class="name">UniformEmbedding</span>.<span class="name">of_comp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">(<span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.of_comp_iff">IsUniformEmbedding.of_comp_iff</a></code>.</p></div></div><div class="decl" id="Equiv.isUniformEmbedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Equiv.isUniformEmbedding"><span class="name">Equiv</span>.<span class="name">isUniformEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">⇑<span class="fn">f</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">⇑<span class="fn"><span class="fn">f</span>.symm</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">⇑<span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="Equiv.uniformEmbedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated Equiv.isUniformEmbedding]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Equiv.uniformEmbedding"><span class="name">Equiv</span>.<span class="name">uniformEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">⇑<span class="fn">f</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">⇑<span class="fn"><span class="fn">f</span>.symm</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">⇑<span class="fn">f</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Equiv.isUniformEmbedding">Equiv.isUniformEmbedding</a></code>.</p></div></div><div class="decl" id="isUniformEmbedding_inl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_inl"><span class="name">isUniformEmbedding_inl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">Sum.inl</span></span></div></div></div></div><div class="decl" id="uniformEmbedding_inl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated isUniformEmbedding_inl]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformEmbedding_inl"><span class="name">uniformEmbedding_inl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">Sum.inl</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_inl">isUniformEmbedding_inl</a></code>.</p></div></div><div class="decl" id="isUniformEmbedding_inr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_inr"><span class="name">isUniformEmbedding_inr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">Sum.inr</span></span></div></div></div></div><div class="decl" id="uniformEmbedding_inr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated isUniformEmbedding_inr]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformEmbedding_inr"><span class="name">uniformEmbedding_inr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">Sum.inr</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_inr">isUniformEmbedding_inr</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.isUniformEmbedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.isUniformEmbedding"><span class="name">IsUniformInducing</span>.<span class="name">isUniformEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T0Space">T0Space</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span></div></div><p>If the domain of a <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a></code> map <code>f</code> is a T₀ space, then <code>f</code> is injective,
hence it is a <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a></code>.</p></div></div><div class="decl" id="UniformInducing.isUniformEmbedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.isUniformEmbedding]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.isUniformEmbedding"><span class="name">UniformInducing</span>.<span class="name">isUniformEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T0Space">T0Space</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.isUniformEmbedding">IsUniformInducing.isUniformEmbedding</a></code>.</p><hr></hr><p>If the domain of a <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a></code> map <code>f</code> is a T₀ space, then <code>f</code> is injective,
hence it is a <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.uniformEmbedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.isUniformEmbedding]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.uniformEmbedding"><span class="name">IsUniformInducing</span>.<span class="name">uniformEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T0Space">T0Space</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.isUniformEmbedding">IsUniformInducing.isUniformEmbedding</a></code>.</p><hr></hr><p>If the domain of a <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a></code> map <code>f</code> is a T₀ space, then <code>f</code> is injective,
hence it is a <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a></code>.</p></div></div><div class="decl" id="isUniformEmbedding_iff_isUniformInducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_iff_isUniformInducing"><span class="name">isUniformEmbedding_iff_isUniformInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T0Space">T0Space</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="isUniformEmbedding_iff_uniformInducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated isUniformEmbedding_iff_isUniformInducing]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_iff_uniformInducing"><span class="name">isUniformEmbedding_iff_uniformInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T0Space">T0Space</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_iff_isUniformInducing">isUniformEmbedding_iff_isUniformInducing</a></code>.</p></div></div><div class="decl" id="uniformEmbedding_iff_isUniformInducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated isUniformEmbedding_iff_isUniformInducing]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformEmbedding_iff_isUniformInducing"><span class="name">uniformEmbedding_iff_isUniformInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T0Space">T0Space</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_iff_isUniformInducing">isUniformEmbedding_iff_isUniformInducing</a></code>.</p></div></div><div class="decl" id="comap_uniformity_of_spaced_out"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#comap_uniformity_of_spaced_out"><span class="name">comap_uniformity_of_spaced_out</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hs : <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun (<span class="fn">x</span> <span class="fn">y</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> ∉ <span class="fn">s</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">(<a href="../../.././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">f</span> <span class="fn">f</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">idRel</span></span></span></div></div><p>If a map <code>f : α → β</code> sends any two distinct points to point that are <strong>not</strong> related by a fixed
<code>s ∈ 𝓤 β</code>, then <code>f</code> is uniform inducing with respect to the discrete uniformity on <code>α</code>:
the preimage of <code>𝓤 β</code> under <code><a href="../../.././Init/Core.html#Prod.map">Prod.map</a> f f</code> is the principal filter generated by the diagonal in
<code>α × α</code>.</p></div></div><div class="decl" id="isUniformEmbedding_of_spaced_out"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_of_spaced_out"><span class="name">isUniformEmbedding_of_spaced_out</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hs : <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun (<span class="fn">x</span> <span class="fn">y</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> ∉ <span class="fn">s</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span></div></div><p>If a map <code>f : α → β</code> sends any two distinct points to point that are <strong>not</strong> related by a fixed
<code>s ∈ 𝓤 β</code>, then <code>f</code> is a uniform embedding with respect to the discrete uniformity on <code>α</code>.</p></div></div><div class="decl" id="uniformEmbedding_of_spaced_out"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated isUniformEmbedding_of_spaced_out]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformEmbedding_of_spaced_out"><span class="name">uniformEmbedding_of_spaced_out</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hs : <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun (<span class="fn">x</span> <span class="fn">y</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> ∉ <span class="fn">s</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_of_spaced_out">isUniformEmbedding_of_spaced_out</a></code>.</p><hr></hr><p>If a map <code>f : α → β</code> sends any two distinct points to point that are <strong>not</strong> related by a fixed
<code>s ∈ 𝓤 β</code>, then <code>f</code> is a uniform embedding with respect to the discrete uniformity on <code>α</code>.</p></div></div><div class="decl" id="IsUniformEmbedding.embedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.embedding"><span class="name">IsUniformEmbedding</span>.<span class="name">embedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Embedding">Embedding</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="UniformEmbedding.embedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformEmbedding.embedding]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformEmbedding.embedding"><span class="name">UniformEmbedding</span>.<span class="name">embedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Embedding">Embedding</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.embedding">IsUniformEmbedding.embedding</a></code>.</p></div></div><div class="decl" id="IsUniformEmbedding.isDenseEmbedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.isDenseEmbedding"><span class="name">IsUniformEmbedding</span>.<span class="name">isDenseEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hd : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#DenseRange">DenseRange</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/DenseEmbedding.html#IsDenseEmbedding">IsDenseEmbedding</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="UniformEmbedding.isDenseEmbedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformEmbedding.isDenseEmbedding]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformEmbedding.isDenseEmbedding"><span class="name">UniformEmbedding</span>.<span class="name">isDenseEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hd : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#DenseRange">DenseRange</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/DenseEmbedding.html#IsDenseEmbedding">IsDenseEmbedding</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.isDenseEmbedding">IsUniformEmbedding.isDenseEmbedding</a></code>.</p></div></div><div class="decl" id="IsUniformEmbedding.denseEmbedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformEmbedding.isDenseEmbedding]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.denseEmbedding"><span class="name">IsUniformEmbedding</span>.<span class="name">denseEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hd : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#DenseRange">DenseRange</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/DenseEmbedding.html#IsDenseEmbedding">IsDenseEmbedding</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.isDenseEmbedding">IsUniformEmbedding.isDenseEmbedding</a></code>.</p></div></div><div class="decl" id="closedEmbedding_of_spaced_out"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#closedEmbedding_of_spaced_out"><span class="name">closedEmbedding_of_spaced_out</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Order.html#DiscreteTopology">DiscreteTopology</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T0Space">T0Space</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hs : <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun (<span class="fn">x</span> <span class="fn">y</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span> ∉ <span class="fn">s</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#ClosedEmbedding">ClosedEmbedding</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="closure_image_mem_nhds_of_isUniformInducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#closure_image_mem_nhds_of_isUniformInducing"><span class="name">closure_image_mem_nhds_of_isUniformInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(he₁ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(he₂ : <span class="fn"><a href="../../.././Mathlib/Topology/DenseEmbedding.html#IsDenseInducing">IsDenseInducing</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hs : <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> <span class="fn">(<span class="fn">e</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">{<span class="fn">a'</span> : <span class="fn">α</span> | <span class="fn"><span class="fn">(<span class="fn">a</span>, <span class="fn">a'</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>}</span>)</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="closure_image_mem_nhds_of_uniformInducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated closure_image_mem_nhds_of_isUniformInducing]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#closure_image_mem_nhds_of_uniformInducing"><span class="name">closure_image_mem_nhds_of_uniformInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(he₁ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(he₂ : <span class="fn"><a href="../../.././Mathlib/Topology/DenseEmbedding.html#IsDenseInducing">IsDenseInducing</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hs : <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> <span class="fn">(<span class="fn">e</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">{<span class="fn">a'</span> : <span class="fn">α</span> | <span class="fn"><span class="fn">(<span class="fn">a</span>, <span class="fn">a'</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>}</span>)</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">b</span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#closure_image_mem_nhds_of_isUniformInducing">closure_image_mem_nhds_of_isUniformInducing</a></code>.</p></div></div><div class="decl" id="isUniformEmbedding_subtypeEmb"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_subtypeEmb"><span class="name">isUniformEmbedding_subtypeEmb</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ue : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(de : <span class="fn"><a href="../../.././Mathlib/Topology/DenseEmbedding.html#IsDenseEmbedding">IsDenseEmbedding</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">(<a href="../../.././Mathlib/Topology/DenseEmbedding.html#IsDenseEmbedding.subtypeEmb">IsDenseEmbedding.subtypeEmb</a> <span class="fn">p</span> <span class="fn">e</span>)</span></span></div></div></div></div><div class="decl" id="uniformEmbedding_subtypeEmb"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated isUniformEmbedding_subtypeEmb]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformEmbedding_subtypeEmb"><span class="name">uniformEmbedding_subtypeEmb</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ue : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(de : <span class="fn"><a href="../../.././Mathlib/Topology/DenseEmbedding.html#IsDenseEmbedding">IsDenseEmbedding</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">(<a href="../../.././Mathlib/Topology/DenseEmbedding.html#IsDenseEmbedding.subtypeEmb">IsDenseEmbedding.subtypeEmb</a> <span class="fn">p</span> <span class="fn">e</span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_subtypeEmb">isUniformEmbedding_subtypeEmb</a></code>.</p></div></div><div class="decl" id="IsUniformEmbedding.prod"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.prod"><span class="name">IsUniformEmbedding</span>.<span class="name">prod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α' : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β' : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e₁ : <span class="fn"><span class="fn">α</span> → <span class="fn">α'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e₂ : <span class="fn"><span class="fn">β</span> → <span class="fn">β'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">e₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">e₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">fun (<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>) =&gt; <span class="fn">(<span class="fn"><span class="fn">e₁</span> <span class="fn"><span class="fn">p</span>.1</span></span>, <span class="fn"><span class="fn">e₂</span> <span class="fn"><span class="fn">p</span>.2</span></span>)</span></span></span></div></div></div></div><div class="decl" id="UniformEmbedding.prod"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformEmbedding.prod]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformEmbedding.prod"><span class="name">UniformEmbedding</span>.<span class="name">prod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α' : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β' : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e₁ : <span class="fn"><span class="fn">α</span> → <span class="fn">α'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e₂ : <span class="fn"><span class="fn">β</span> → <span class="fn">β'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">e₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">e₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">fun (<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>) =&gt; <span class="fn">(<span class="fn"><span class="fn">e₁</span> <span class="fn"><span class="fn">p</span>.1</span></span>, <span class="fn"><span class="fn">e₂</span> <span class="fn"><span class="fn">p</span>.2</span></span>)</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.prod">IsUniformEmbedding.prod</a></code>.</p></div></div><div class="decl" id="isComplete_image_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isComplete_image_iff"><span class="name">isComplete_image_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hm : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">(<span class="fn">m</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">s</span></span></span></div></div><p>A set is complete iff its image under a uniform inducing map is complete.</p></div></div><div class="decl" id="IsUniformInducing.isComplete_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.isComplete_iff"><span class="name">IsUniformInducing</span>.<span class="name">isComplete_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">(<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">s</span></span></span></div></div><p>If <code>f : X → Y</code> is an <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a></code> map, the image <code>f '' s</code> of a set <code>s</code> is complete
if and only if <code>s</code> is complete.</p></div></div><div class="decl" id="UniformInducing.isComplete_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.isComplete_iff]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.isComplete_iff"><span class="name">UniformInducing</span>.<span class="name">isComplete_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">(<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">s</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.isComplete_iff">IsUniformInducing.isComplete_iff</a></code>.</p><hr></hr><p>If <code>f : X → Y</code> is an <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a></code> map, the image <code>f '' s</code> of a set <code>s</code> is complete
if and only if <code>s</code> is complete.</p></div></div><div class="decl" id="IsUniformEmbedding.isComplete_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.isComplete_iff"><span class="name">IsUniformEmbedding</span>.<span class="name">isComplete_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">(<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">s</span></span></span></div></div><p>If <code>f : X → Y</code> is an <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a></code>, the image <code>f '' s</code> of a set <code>s</code> is complete
if and only if <code>s</code> is complete.</p></div></div><div class="decl" id="UniformEmbedding.isComplete_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformEmbedding.isComplete_iff]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformEmbedding.isComplete_iff"><span class="name">UniformEmbedding</span>.<span class="name">isComplete_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">(<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">s</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding.isComplete_iff">IsUniformEmbedding.isComplete_iff</a></code>.</p><hr></hr><p>If <code>f : X → Y</code> is an <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a></code>, the image <code>f '' s</code> of a set <code>s</code> is complete
if and only if <code>s</code> is complete.</p></div></div><div class="decl" id="Subtype.isComplete_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Subtype.isComplete_iff"><span class="name">Subtype</span>.<span class="name">isComplete_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">{ <span class="fn">x</span> : <span class="fn">α</span> // <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> }</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">(<span class="fn">Subtype.val</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></span></span></div></div><p>Sets of a subtype are complete iff their image under the coercion is complete.</p></div></div><div class="decl" id="isComplete_of_complete_image"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isComplete_of_complete_image"><span class="name">isComplete_of_complete_image</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hm : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">(<span class="fn">m</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></span> → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">s</span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isComplete_image_iff">isComplete_image_iff</a></code>.</p><hr></hr><p>A set is complete iff its image under a uniform inducing map is complete.</p></div></div><div class="decl" id="completeSpace_iff_isComplete_range"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#completeSpace_iff_isComplete_range"><span class="name">completeSpace_iff_isComplete_range</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">f</span>)</span></span></span></div></div></div></div><div class="decl" id="IsUniformInducing.completeSpace"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.completeSpace"><span class="name">IsUniformInducing</span>.<span class="name">completeSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">f</span>)</span></span> → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#completeSpace_iff_isComplete_range">completeSpace_iff_isComplete_range</a></code>.</p></div></div><div class="decl" id="UniformInducing.completeSpace"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.completeSpace]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.completeSpace"><span class="name">UniformInducing</span>.<span class="name">completeSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">f</span>)</span></span> → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#completeSpace_iff_isComplete_range">completeSpace_iff_isComplete_range</a></code>.</p><hr></hr><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#completeSpace_iff_isComplete_range">completeSpace_iff_isComplete_range</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.isComplete_range"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.isComplete_range"><span class="name">IsUniformInducing</span>.<span class="name">isComplete_range</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="UniformInducing.isComplete_range"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.isComplete_range]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.isComplete_range"><span class="name">UniformInducing</span>.<span class="name">isComplete_range</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">f</span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.isComplete_range">IsUniformInducing.isComplete_range</a></code>.</p></div></div><div class="decl" id="IsUniformInducing.completeSpace_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.completeSpace_congr"><span class="name">IsUniformInducing</span>.<span class="name">completeSpace_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hsurj : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Surjective">Function.Surjective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">β</span></span></span></div></div><p>If <code>f</code> is a surjective uniform inducing map,
then its domain is a complete space iff its codomain is a complete space.
See also <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#completeSpace_congr">_root_.completeSpace_congr</a></code> for a version that assumes <code>f</code> to be an equivalence.</p></div></div><div class="decl" id="UniformInducing.completeSpace_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated IsUniformInducing.completeSpace_congr]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing.completeSpace_congr"><span class="name">UniformInducing</span>.<span class="name">completeSpace_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hsurj : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Surjective">Function.Surjective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">β</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.completeSpace_congr">IsUniformInducing.completeSpace_congr</a></code>.</p><hr></hr><p>If <code>f</code> is a surjective uniform inducing map,
then its domain is a complete space iff its codomain is a complete space.
See also <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#completeSpace_congr">_root_.completeSpace_congr</a></code> for a version that assumes <code>f</code> to be an equivalence.</p></div></div><div class="decl" id="SeparationQuotient.completeSpace_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#SeparationQuotient.completeSpace_iff"><span class="name">SeparationQuotient</span>.<span class="name">completeSpace_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#SeparationQuotient">SeparationQuotient</a> <span class="fn">α</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span></span></div></div></div></div><div class="decl" id="SeparationQuotient.instCompleteSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#SeparationQuotient.instCompleteSpace"><span class="name">SeparationQuotient</span>.<span class="name">instCompleteSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#SeparationQuotient">SeparationQuotient</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="completeSpace_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#completeSpace_congr"><span class="name">completeSpace_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">α</span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(he : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">⇑<span class="fn">e</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">β</span></span></span></div></div><p>See also <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing.completeSpace_congr">IsUniformInducing.completeSpace_congr</a></code>
for a version that works for non-injective maps.</p></div></div><div class="decl" id="completeSpace_coe_iff_isComplete"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#completeSpace_coe_iff_isComplete"><span class="name">completeSpace_coe_iff_isComplete</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">↑<span class="fn">s</span></span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="IsComplete.completeSpace_coe"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsComplete.completeSpace_coe"><span class="name">IsComplete</span>.<span class="name">completeSpace_coe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#IsComplete">IsComplete</a> <span class="fn">s</span></span> → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">↑<span class="fn">s</span></span></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#completeSpace_coe_iff_isComplete">completeSpace_coe_iff_isComplete</a></code>.</p></div></div><div class="decl" id="IsClosed.completeSpace_coe"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsClosed.completeSpace_coe"><span class="name">IsClosed</span>.<span class="name">completeSpace_coe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hs : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">↑<span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="completeSpace_ulift_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#completeSpace_ulift_iff"><span class="name">completeSpace_ulift_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">(<a href="../../.././Init/Prelude.html#ULift">ULift.{u_1, u}</a>    <span class="fn">α</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span></span></div></div></div></div><div class="decl" id="ULift.instCompleteSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#ULift.instCompleteSpace"><span class="name">ULift</span>.<span class="name">instCompleteSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">(<a href="../../.././Init/Prelude.html#ULift">ULift.{u_1, u}</a>    <span class="fn">α</span>)</span></span></div></div><p>The lift of a complete space to another universe is still complete.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="completeSpace_extension"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#completeSpace_extension"><span class="name">completeSpace_extension</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hm : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(dense : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#DenseRange">DenseRange</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#Cauchy">Cauchy</a> <span class="fn">f</span></span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">m</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="totallyBounded_image_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#totallyBounded_image_iff"><span class="name">totallyBounded_image_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#TotallyBounded">TotallyBounded</a> <span class="fn">(<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#TotallyBounded">TotallyBounded</a> <span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="totallyBounded_preimage"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#totallyBounded_preimage"><span class="name">totallyBounded_preimage</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hs : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#TotallyBounded">TotallyBounded</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#TotallyBounded">TotallyBounded</a> <span class="fn">(<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">⁻¹'</a> <span class="fn">s</span>)</span></span></div></div></div></div><div class="decl" id="CompleteSpace.sum"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#CompleteSpace.sum"><span class="name">CompleteSpace</span>.<span class="name">sum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Core.html#Sum">⊕</a> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="isUniformEmbedding_comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_comap"><span class="name">isUniformEmbedding_comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[u : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="uniformEmbedding_comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated isUniformEmbedding_comap]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformEmbedding_comap"><span class="name">uniformEmbedding_comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[u : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#isUniformEmbedding_comap">isUniformEmbedding_comap</a></code>.</p></div></div><div class="decl" id="Embedding.comapUniformSpace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Embedding.comapUniformSpace"><span class="name">Embedding</span>.<span class="name">comapUniformSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[u : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Embedding">Embedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span></div></div><p>Pull back a uniform space structure by an embedding, adjusting the new uniform structure to
make sure that its topology is defeq to the original one.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Embedding.comapUniformSpace">Embedding.comapUniformSpace</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> <span class="fn">f</span> <span class="fn">u</span>)</span>.replaceTopology</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Embedding.comapUniformSpace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Embedding.to_isUniformEmbedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Embedding.to_isUniformEmbedding"><span class="name">Embedding</span>.<span class="name">to_isUniformEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[u : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Embedding">Embedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Embedding.to_uniformEmbedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="attributes">@[deprecated Embedding.to_isUniformEmbedding]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Embedding.to_uniformEmbedding"><span class="name">Embedding</span>.<span class="name">to_uniformEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[u : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Embedding">Embedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#Embedding.to_isUniformEmbedding">Embedding.to_isUniformEmbedding</a></code>.</p></div></div><div class="decl" id="uniformly_extend_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformly_extend_exists"><span class="name">uniformly_extend_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h_e : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_dense : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#DenseRange">DenseRange</a> <span class="fn">e</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h_f : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">c</span> : <span class="fn">γ</span>), <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Filter.Tendsto</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">e</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">a</span>)</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">c</span>)</span></span></span></div></div></div></div><div class="decl" id="uniform_extend_subtype"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniform_extend_subtype"><span class="name">uniform_extend_subtype</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Subtype">Subtype</a> <span class="fn">p</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">↑<span class="fn">x</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(he : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hd : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">e</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> <span class="fn">(<span class="fn">e</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hs : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hp : <span class="fn">∀ <span class="fn">x</span> ∈ <span class="fn">s</span>, <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">c</span> : <span class="fn">γ</span>), <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Filter.Tendsto</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">e</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">b</span>)</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">c</span>)</span></span></span></div></div></div></div><div class="decl" id="uniformly_extend_spec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformly_extend_spec"><span class="name">uniformly_extend_spec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h_e : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_dense : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#DenseRange">DenseRange</a> <span class="fn">e</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h_f : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Filter.Tendsto</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">e</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">a</span>)</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">(<span class="fn"><span class="fn">⋯</span>.extend</span> <span class="fn">f</span> <span class="fn">a</span>)</span>)</span></span></div></div></div></div><div class="decl" id="uniformContinuous_uniformly_extend"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformContinuous_uniformly_extend"><span class="name">uniformContinuous_uniformly_extend</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h_e : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_dense : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#DenseRange">DenseRange</a> <span class="fn">e</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h_f : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">(<span class="fn"><span class="fn">⋯</span>.extend</span> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="uniformly_extend_of_ind"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformly_extend_of_ind"><span class="name">uniformly_extend_of_ind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h_e : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_dense : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#DenseRange">DenseRange</a> <span class="fn">e</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h_f : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T0Space">T0Space</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">⋯</span>.extend</span> <span class="fn">f</span> <span class="fn">(<span class="fn">e</span> <span class="fn">b</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="uniformly_extend_unique"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/3ae6376f67d90e32a4dfbee23157ac3ac4b5508c/Mathlib/Topology/UniformSpace/UniformEmbedding.lean">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#uniformly_extend_unique"><span class="name">uniformly_extend_unique</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h_e : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_dense : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#DenseRange">DenseRange</a> <span class="fn">e</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T0Space">T0Space</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hg : <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">e</span> <span class="fn">b</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hc : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">⋯</span>.extend</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>